<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset="utf-8" />
		<title>Minecraft Spiral Generator</title>
		<link rel="stylesheet" href="style.css" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap"
			rel="stylesheet"
		/>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
	</head>
	<body>
		<div>
			<h1>Minecraft Spiral Generator</h1>
			<div class="sliderContainer">
				<div>
					Height of the spiral (in blocks)
					<input
						type="range"
						id="blocks_wide"
						name="blocks_wide"
						min="8"
						max="80"
						step="2"
					/>
				</div>
				<div>
					Scale of the spiral pattern
					<input
						type="range"
						id="spiral_scale"
						name="spiral_scale"
						min="0.6"
						max="1.3"
						step="any"
					/>
				</div>
				<div>
					How much bigger spiral gets near edges
					<input
						type="range"
						id="radial_scale"
						name="radial_scale"
						min="0.01"
						max="0.33"
						step="any"
					/>
				</div>
				<div>
					Thickness of spiral
					<input
						type="range"
						id="fullness"
						name="fullness"
						min="0.1"
						max="1.0"
						step="0.01"
					/>
				</div>
				<div>
					Center Cut
					<input
						type="range"
						id="cut"
						name="cut"
						min="0.0"
						max="2.0"
						step="0.01"
					/>
				</div>
				<div>
					Rotation
					<input
						type="range"
						id="rotation"
						name="rotation"
						min="0.0"
						max="6.28318530718"
						step="0.01"
					/>
				</div>
			</div>
			<h2>Generated Spiral</h2>
			<p>Use right click to pan around. Use mouse wheel to zoom.</p>
		<script id="fragmentShader" type="x-shader/x-fragment">
			#define PI 3.141593
			#define PI2 6.283186

			uniform float fullness;
			uniform float blocks_wide;
			uniform float scale;
			uniform float radial_scale;
			uniform float rotation;
			uniform float screenHeight;
			uniform float screenWidth;
			uniform float cut;
			uniform vec2 translate;
			uniform float zoom;

			float dArchSpiral(in vec2 p, float a, float d)
			{
				float sp = 1.0;
				float r = length(p);

				a = a + radial_scale * r;
				float t = cut;
				float nt = t - (PI / 2.0);

				float inv_t = 1.0 / t;
				float m = (inv_t * sin(t) + cos(t)) / (inv_t * cos(t) - sin(t));

				float extra_angles = 0.0;
				if (t < 0.87) {
					extra_angles = -PI;
				}

				vec2 rot_p = vec2(
					p.x * cos(rotation) + p.y * sin(rotation),
					p.y * cos(rotation) - p.x * sin(rotation)
				);

				float bounds = sqrt(
					pow(rot_p.x + t * a / PI2 * (cos(nt)- cos(atan(m) + extra_angles)), 2.0) +
					pow(rot_p.y + t * a / PI2 * (sin(nt)- sin(atan(m) + extra_angles)), 2.0)
				);

				if (bounds < t * a / PI2) {
					return 0.0;
				}

				d *= 3.0 / PI;

				float theta1 = atan(rot_p.x, rot_p.y)/PI2;
				float theta2 = atan(rot_p.x, rot_p.y)/PI2 - d;

				float dist = (abs(fract(theta2 + r / a)) - abs(fract(theta1 + r / a)));
				if (dist >= 0.000001) {
					return 1.0;
				}
				return 0.0;
			}

			void main()
			{
			    vec2 iResolution = vec2(screenWidth,screenHeight);
			    float gs = blocks_wide / 2.0;
			    vec2 p = ((2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y-vec2(translate.x,-translate.y)/300.0)/zoom;

			    float ps = gs / iResolution.y;
			    float col_1 = dArchSpiral(floor(p * gs) / gs + ps * 0.25, scale, fullness);
			    float col_2 = dArchSpiral(floor(p * gs) / gs + ps * 0.75, scale, fullness);
				float col_5 = dArchSpiral(floor(p * gs) / gs + ps * 0.5, scale, fullness);

			    vec2 block_number = vec2(floor(p.x * gs),floor(p.y * gs));

			    vec2 sample_3 = vec2(
			        floor(p.x * gs) / gs + ps * 0.25,
			        floor(p.y * gs) / gs + ps * 0.75
			    );

			    vec2 sample_4 = vec2(
			        floor(p.x * gs) / gs + ps * 0.75,
			        floor(p.y * gs) / gs + ps * 0.25
			    );

			    float col_3 = dArchSpiral(sample_3, scale, fullness);
			    float col_4 = dArchSpiral(floor(p * gs) / gs + ps * 0.75, scale, fullness);

			    if (col_1 + col_2 + col_3 + col_4 + col_5 >= 1.0) {
			        gl_FragColor = vec4(0.95,0.9,0.8,1.0);
			    } else {
			        gl_FragColor = vec4(0.45,0.05,0.15,1.0);
			    }

			    if (block_number.x + block_number.y - 2.0 * floor((block_number.x + block_number.y) / 2.0) == 0.0) {
			        gl_FragColor *= vec4(0.5,0.55,0.55,1.0);
			    }
			}
		</script>
		<script>
			const SIZE = 600;
			const renderer = new THREE.WebGLRenderer();
			document.body.appendChild(renderer.domElement);

			const fullness_input = document.querySelector("#fullness");
			const blocks_wide_input = document.querySelector("#blocks_wide");
			const spiral_scale_input = document.querySelector("#spiral_scale");
			const radial_scale_input = document.querySelector("#radial_scale");
			const cut_input = document.querySelector("#cut");
			const rotation_input = document.querySelector("#rotation");

			var FULLNESS = fullness_input.value;
			var BLOCKS_WIDE = blocks_wide_input.value;
			var SPIRAL_SCALE = spiral_scale_input.value;
			var RADIAL_SCALE = radial_scale_input.value;
			var CUT = cut_input.value;
			var ROTATION = rotation_input.value;
			var TRANSLATE = {x: 0, y: 0}
			var ZOOM = 1;

			const camera = new THREE.OrthographicCamera(
				SIZE / -2,
				SIZE / 2,
				SIZE / 2,
				SIZE / -2,
				0.1,
				1000
			);

			function render_scene() {
				const scene = new THREE.Scene();
				const glsl = (x) => x[0];

				const geometry = new THREE.PlaneGeometry(SIZE, SIZE);

				const material = new THREE.ShaderMaterial({
					uniforms: {
						fullness: { value: FULLNESS },
						blocks_wide: {
							value: BLOCKS_WIDE,
						},
						scale: { value: SPIRAL_SCALE },
						radial_scale: { value: RADIAL_SCALE },
						screenWidth: { value: SIZE },
						screenHeight: { value: SIZE },
						cut: { value: CUT },
						rotation: { value: ROTATION },
						translate: {value: TRANSLATE},
						zoom: {value: ZOOM}
					},
					fragmentShader:
						document.getElementById("fragmentShader").textContent,
				});
				const plane = new THREE.Mesh(geometry, material);
				scene.add(plane);

				renderer.setSize(SIZE, SIZE);
				document.body.appendChild(renderer.domElement);

				camera.position.z = 1;

				renderer.render(scene, camera);
			}

			render_scene();

			fullness_input.addEventListener("input", (event) => {
				FULLNESS = event.target.value;
				render_scene();
			});
			blocks_wide_input.addEventListener("input", (event) => {
				BLOCKS_WIDE = event.target.value;
				render_scene();
			});
			spiral_scale_input.addEventListener("input", (event) => {
				SPIRAL_SCALE = event.target.value * event.target.value;
				render_scene();
			});
			radial_scale_input.addEventListener("input", (event) => {
				RADIAL_SCALE = event.target.value;
				render_scene();
			});
			radial_scale_input.addEventListener("input", (event) => {
				RADIAL_SCALE = event.target.value;
				render_scene();
			});
			cut_input.addEventListener("input", (event) => {
				CUT = event.target.value;
				render_scene();
			});
			rotation_input.addEventListener("input", (event) => {
				ROTATION = event.target.value;
				render_scene();
			});

			let dragStart = {x: 0, y: 0};
			let drag = false;

			renderer.domElement.addEventListener("mousedown", function (event) {
				dragStart = {
					x: event.pageX - renderer.domElement.offsetLeft,
					y: event.pageY - renderer.domElement.offsetTop,
				};
				drag = true

			});

			addEventListener("mousemove", function (event) {
				newPos = {
					x: event.pageX - renderer.domElement.offsetLeft,
					y: event.pageY - renderer.domElement.offsetTop,
				};
				if (drag) {
					TRANSLATE = {
						x: TRANSLATE.x - dragStart.x + newPos.x,
						y: TRANSLATE.y - dragStart.y + newPos.y
					}
					dragStart = {
						x: newPos.x,
						y: newPos.y
					}
				}
				render_scene();
			});

			renderer.domElement.addEventListener("wheel", (event) => {
				event.preventDefault()
				event.stopPropagation()
				console.log(event.deltaY)
				if (event.deltaY < 0 && ZOOM < 2.0) {
					ZOOM += ZOOM * 0.2;
				} else if (event.deltaY > 0 && ZOOM > 0.3) {
					ZOOM -= ZOOM * 0.2;
				}
				render_scene();
			 }, { passive: false })

			addEventListener("mouseup", function (event) {
				drag = false
			});
		</script>
	</body>
</html>
