<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset="utf-8" />
		<title>Minecraft Spiral Generator</title>
		<link rel="stylesheet" href="style.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
	</head>
	<body>
		<div>
			<h1>Minecraft Spiral Generator</h1>
			<div class="sliderContainer">
				<div>
					Height of the spiral (in blocks)
					<input
						type="range"
						id="blocks_wide"
						name="blocks_wide"
						min="8"
						max="80"
						step="2"
					/>
				</div>
				<div>
					Scale of the spiral pattern
					<input
						type="range"
						id="spiral_scale"
						name="spiral_scale"
						min="0.1"
						max="2.0"
						step="any"
					/>
				</div>
				<div>
					How much bigger spiral gets near edges
					<input
						type="range"
						id="radial_scale"
						name="radial_scale"
						min="0.01"
						max="0.33"
						step="any"
					/>
				</div>
				<div>
					Thickness of spiral
					<input
						type="range"
						id="fullness"
						name="fullness"
						min="0.1"
						max="1.0"
						step="0.01"
					/>
				</div>
				<div>
					Center Cut
					<input
						type="range"
						id="cut"
						name="cut"
						min="0.0"
						max="2.0"
						step="0.01"
					/>
				</div>
			</div>
			<h2>Generated Spiral</h2>
		</div>
		<script id="vertexShader" type="x-shader/x-vertex">
			// vertex shader's code goes here
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			#define PI 3.141593
			#define PI2 6.283186

			uniform float fullness;
			uniform float blocks_wide;
			uniform float scale;
			uniform float radial_scale;
			uniform float screenHeight;
			uniform float screenWidth;
			uniform float t;

			float dArchSpiral(in vec2 p, float a, float d)
			{
				float sp = 1.0;
				float r = length(p);

				a = a + radial_scale * r;

				float nt = t - (PI / 2.0);

				float inv_t = 1.0 / t;
				float m = (inv_t * sin(t) + cos(t)) / (inv_t * cos(t) - sin(t));

				float extra_angles = 0.0;
				if (t < 0.87) {
					extra_angles = - PI;
				}

				float bounds = sqrt(
					pow(p.x + t * a / PI2 * (cos(nt) - cos(atan(m) + extra_angles)), 2.0) +
					pow(p.y + t * a / PI2 * (sin(nt) - sin(atan(m) + extra_angles)), 2.0)
				);

				if (bounds < t * a / PI2) {
					return 0.0;
				}

				d *= 3.0 / PI;

				float theta1 = atan(p.x, p.y)/PI2;
				float theta2 = atan(p.x, p.y)/PI2 - d;

				float dist = (abs(fract(theta2 + r / a)) - abs(fract(theta1 + r / a)));
				if (dist >= 0.000001) {
					return 1.0;
				}
				return 0.0;
			}

			void main()
			{
			    vec2 iResolution = vec2(screenWidth,screenHeight);
			    float gs = blocks_wide / 2.0;
			    vec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;

			    float ps = gs / iResolution.y;
			    float col_1 = dArchSpiral(floor(p * gs) / gs + ps * 0.25, scale, fullness);
			    float col_2 = dArchSpiral(floor(p * gs) / gs + ps * 0.75, scale, fullness);
				float col_5 = dArchSpiral(floor(p * gs) / gs + ps * 0.5, scale, fullness);

			    vec2 block_number = vec2(floor(p.x * gs),floor(p.y * gs));

			    vec2 sample_3 = vec2(
			        floor(p.x * gs) / gs + ps * 0.25,
			        floor(p.y * gs) / gs + ps * 0.75
			    );

			    vec2 sample_4 = vec2(
			        floor(p.x * gs) / gs + ps * 0.75,
			        floor(p.y * gs) / gs + ps * 0.25
			    );

			    float col_3 = dArchSpiral(sample_3, scale, fullness);
			    float col_4 = dArchSpiral(floor(p * gs) / gs + ps * 0.75, scale, fullness);

			    if (col_1 + col_2 + col_3 + col_4 + col_5 > 0.5) {
			        gl_FragColor = vec4(0.95,0.9,0.8,1.0);
			    } else {
			        gl_FragColor = vec4(0.45,0.05,0.15,1.0);
			    }

			    if (block_number.x + block_number.y - 2.0 * floor((block_number.x + block_number.y) / 2.0) == 0.0) {
			        gl_FragColor *= vec4(0.5,0.55,0.55,1.0);
			    }
			}
		</script>
		<script>
			const SIZE = 500;
			const renderer = new THREE.WebGLRenderer();
			document.body.appendChild(renderer.domElement);

			const fullness_input = document.querySelector("#fullness");
			const blocks_wide_input = document.querySelector("#blocks_wide");
			const spiral_scale_input = document.querySelector("#spiral_scale");
			const radial_scale_input = document.querySelector("#radial_scale");
			const cut_input = document.querySelector("#cut");

			var FULLNESS = fullness_input.value;
			var BLOCKS_WIDE = blocks_wide_input.value;
			var SPIRAL_SCALE = spiral_scale_input.value;
			var RADIAL_SCALE = radial_scale_input.value;
			var CUT = cut_input.value;

			const camera = new THREE.OrthographicCamera(
				SIZE / -2,
				SIZE / 2,
				SIZE / 2,
				SIZE / -2,
				0.1,
				1000
			);

			function render_scene() {
				const scene = new THREE.Scene();
				const glsl = (x) => x[0];

				const geometry = new THREE.PlaneGeometry(SIZE, SIZE);

				const material = new THREE.ShaderMaterial({
					uniforms: {
						fullness: { value: FULLNESS },
						blocks_wide: {
							value: BLOCKS_WIDE,
						},
						scale: { value: Math.sqrt(SPIRAL_SCALE) },
						radial_scale: { value: RADIAL_SCALE },
						screenWidth: { value: SIZE },
						screenHeight: { value: SIZE },
						t: { value: CUT },
					},
					fragmentShader:
						document.getElementById("fragmentShader").textContent,
				});
				const plane = new THREE.Mesh(geometry, material);
				scene.add(plane);

				renderer.setSize(SIZE, SIZE);
				document.body.appendChild(renderer.domElement);

				camera.position.z = 1;

				renderer.render(scene, camera);
			}

			render_scene();

			fullness_input.addEventListener("input", (event) => {
				FULLNESS = event.target.value;
				render_scene();
			});
			blocks_wide_input.addEventListener("input", (event) => {
				BLOCKS_WIDE = event.target.value;
				render_scene();
			});
			spiral_scale_input.addEventListener("input", (event) => {
				SPIRAL_SCALE = event.target.value;
				render_scene();
			});
			radial_scale_input.addEventListener("input", (event) => {
				RADIAL_SCALE = event.target.value;
				render_scene();
			});
			cut_input.addEventListener("input", (event) => {
				CUT = event.target.value;
				render_scene();
			});
		</script>
	</body>
</html>
